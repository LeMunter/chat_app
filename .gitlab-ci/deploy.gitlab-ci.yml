# .create-manifests:
#   stage: deploy
#   rules:
#     - !reference [.rules-deploy, rules]
#   image:
#     name: alpine/helm
#   script:
#     - dep_env="production"
#     - port="32162"
#     - listen_ip="194.47.177.79"
#     - listen_port="80"
#     - cd helm
#     - helm template . --output-dir manifests --set lb_ip=${listen_ip} --set lb_port=${listen_port} --set proxy_port=${port} --set env_name=${dep_env} --set server_img=${CI_REGISTRY_IMAGE}/${CI_COMMIT_BRANCH}/${CI_SERVER_PATH}:${$CI_COMMIT_SHORT_SHA} --set client_img=${CI_REGISTRY_IMAGE}/${CI_COMMIT_BRANCH}/${CI_CLIENT_PATH}:${CI_COMMIT_SHORT_SHA} --set postgres_img=${CI_REGISTRY_IMAGE}/${CI_COMMIT_BRANCH}/${CI_POSTGRES_PATH}:${CI_COMMIT_SHORT_SHA}
#   artifacts:
#     paths:
#       - helm/manifests
#   tags:
#     - $CI_RUNNER_TAG

.deploy:
  stage: deploy
  rules:
    - !reference [.rules-deploy, rules]
  image:
    name: bitnami/kubectl:latest
    entrypoint: [""] # default entry point is kubectl but we want to create the kubeconf first.
  variables:
    test: $IMG_REGISTRY:$CI_COMMIT_BRANCH
  before_script:
    - touch /.kube/config
    - echo "$K8_CONFIG" > /.kube/config
    - cat /.kube/config
  script:
    # - dep_env="production"
    - cd helm/manifests/prod/ChattApp/templates
    - ls -la
    - kubectl create secret docker-registry regcred --namespace="$prod_env" --docker-server="$CI_REGISTRY" --docker-username="$GIT_USERNAME" --docker-password="$GIT_TOKEN" --dry-run=client -o yaml > regcred.yaml
    - kubectl delete -f ./ --ignore-not-found
    - kubectl apply -f ./
  artifacts:
    paths:
      - helm/manifests
  tags:
    - $CI_RUNNER_TAG


